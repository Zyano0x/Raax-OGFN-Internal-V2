#include "exploits.h"

#include <cheat/autorevertfeature.h>
#include <cheat/cache/pickupcache.h>
#include <cheat/core.h>
#include <config/config.h>
#include <drawing/drawing.h>

#include <cheat/hooks.h>

struct FBuildingClassData final {
  public:
    SDK::TSubclassOf<class ABuildingActor> BuildingClass;
    int32_t                                PreviousBuildingLevel;
    int32_t                                UpgradeLevel;
};
struct FortPlayerController_ServerCreateBuildingActor final {
  public:
    FBuildingClassData BuildingClassData;
    SDK::FVector       BuildLoc;
    SDK::FRotator      BuildRot;
    bool               bMirrored;
    uint8_t            Pad_29[0x7];
};

namespace Features {
namespace Exploits {

// --- Exploit Tick Functions ----------------------------------------

static void WeaponExploits(SDK::AFortPlayerPawnAthena* LocalPawn) {
    const auto& Config = Config::g_Config.Exploit;

    if (Config.ADSInAir) {
        auto& Prop = LocalPawn->getpropinfo_bADSWhileNotOnGround(true);
        if (Prop.Found) {
            if (Prop.ByteMask)
                AutoRevertFeature::CreateBitField(LocalPawn->getbitfieldprop_bADSWhileNotOnGround(), &Config.ADSInAir,
                                                  Prop.ByteMask);
            else
                AutoRevertFeature::Create(LocalPawn->getbitfieldprop_bADSWhileNotOnGround(), &Config.ADSInAir);
            LocalPawn->bADSWhileNotOnGround = true;
        }
    }

    SDK::AFortWeapon* Weapon = LocalPawn->CurrentWeapon;
    if (!SDK::AFortWeapon::GetWeaponStats_Idx || !Weapon)
        return;

    SDK::UFortWeaponItemDefinition* WeaponData = Weapon->WeaponData;
    if (!WeaponData)
        return;

    SDK::FFortBaseWeaponStats* WeaponStats = Weapon->GetWeaponStats();
    if (!WeaponStats)
        return;

    if (Config.NoCharge) {
        AutoRevertFeature::CreateScaling(&WeaponStats->MinChargeTime, 0.f, &Config.NoChargeAmount, &Config.NoCharge);
        AutoRevertFeature::CreateScaling(&WeaponStats->MaxChargeTime, 0.f, &Config.NoChargeAmount, &Config.NoCharge);
        AutoRevertFeature::CreateScaling(&WeaponStats->ChargeDownTime, 0.f, &Config.NoChargeAmount, &Config.NoCharge);
        AutoRevertFeature::CreateScaling(&WeaponStats->MinChargeDamageMultiplier, 0.f, &Config.NoChargeAmount,
                                         &Config.NoCharge);
        AutoRevertFeature::CreateScaling(&WeaponStats->MaxChargeDamageMultiplier, 0.f, &Config.NoChargeAmount,
                                         &Config.NoCharge);
    }

    if (Config.AutomaticWeapons) {
        AutoRevertFeature::Create(&WeaponData->TriggerType, &Config.AutomaticWeapons);
        WeaponData->TriggerType = SDK::EFortWeaponTriggerType::Automatic;
    }

    if (Config.DoublePump) {
        auto& Prop = Weapon->getpropinfo_bIgnoreTryToFireSlotCooldownRestriction(true);
        if (Prop.Found) {
            if (Prop.ByteMask)
                AutoRevertFeature::CreateBitField(Weapon->getbitfieldprop_bIgnoreTryToFireSlotCooldownRestriction(),
                                                  &Config.DoublePump, Prop.ByteMask);
            else
                AutoRevertFeature::Create(Weapon->getbitfieldprop_bIgnoreTryToFireSlotCooldownRestriction(),
                                          &Config.DoublePump);
            Weapon->bIgnoreTryToFireSlotCooldownRestriction = true;
        }
    }

    SDK::AFortWeaponRanged* WeaponRanged = SDK::Cast<SDK::AFortWeaponRanged>(Weapon);
    if (WeaponRanged) {
        SDK::FFortRangedWeaponStats* RangedWeaponStats = static_cast<SDK::FFortRangedWeaponStats*>(WeaponStats);
        if (Config.NoSpread) {
            // still dont know why weapons still have spread if you dont change all the "multipliers"
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->Spread, 0.f, &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->SpreadDownsights, 0.f, &Config.NoSpreadAmount,
                                             &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->StandingStillSpreadMultiplier, 0.f,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->AthenaCrouchingSpreadMultiplier, 0.f,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->AthenaJumpingFallingSpreadMultiplier, 0.f,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->AthenaSprintingSpreadMultiplier, 0.f,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->MinSpeedForSpreadMultiplier, FLT_MAX,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->MaxSpeedForSpreadMultiplier, FLT_MAX,
                                             &Config.NoSpreadAmount, &Config.NoSpread);
        }

        if (Config.NoRecoil) {
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->RecoilVert, 0.f, &Config.NoRecoilAmount,
                                             &Config.NoRecoil);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->RecoilVertScaleGamepad, 0.f, &Config.NoRecoilAmount,
                                             &Config.NoRecoil);
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->RecoilHoriz, 0.f, &Config.NoRecoilAmount,
                                             &Config.NoRecoil);
        }

        if (Config.NoReload) {
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->ReloadTime, 0.f, &Config.NoReloadAmount,
                                             &Config.NoReload);
        }

        if (Config.NoReload) {
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->ReloadTime, 0.f, &Config.NoReloadAmount,
                                             &Config.NoReload);
        }

        if (Config.RapidFire) {
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->FiringRate, RangedWeaponStats->FiringRate * 50,
                                             &Config.RapidFireAmount, &Config.RapidFire);
        }

        if (Config.DamageMultiplier) {
            AutoRevertFeature::CreateScaling(&RangedWeaponStats->BulletsPerCartridge,
                                             RangedWeaponStats->BulletsPerCartridge * 50,
                                             &Config.DamageMultiplierAmount, &Config.DamageMultiplier);
        }

        return;
    }

    SDK::AB_Melee_Generic_C* MeleeWeapon = SDK::Cast<SDK::AB_Melee_Generic_C>(Weapon);
    if (MeleeWeapon) {
        SDK::FFortMeleeWeaponStats* MeleeWeaponStats = static_cast<SDK::FFortMeleeWeaponStats*>(WeaponStats);
        if (Config.FastPickaxe) {
            AutoRevertFeature::CreateScaling(&MeleeWeaponStats->SwingPlaySpeed, MeleeWeaponStats->SwingPlaySpeed * 50.f,
                                             &Config.FastPickaxeSpeed, &Config.FastPickaxe);
        }

        return;
    }
}
static void PawnExploits(SDK::AFortPlayerPawnAthena* LocalPawn) {
    const auto& Config = Config::g_Config.Exploit;

    if (Config.ZiplineFly) {
        if (LocalPawn->getpropinfo_ZiplineState(true).Found) {
            LocalPawn->ZiplineState.bIsZiplining = true;
        }
    }

    if (Config.AutoReviveSelf) {
        if (LocalPawn->bIsDBNO) {
            LocalPawn->ServerReviveFromDBNO(SDK::GetLocalController());
        }
    }

    if (Config.InstantRevive) {
        LocalPawn->ReviveFromDBNOTime = 0.1f;
    }

#if 0
    if (GetAsyncKeyState(VK_F9) & 1) {
        auto PC = SDK::Cast<SDK::AFortPlayerController>(SDK::GetLocalController());
        if (PC) {
            static bool done = false;
            if (!done) {
                done = true;
                Hooks::CreateHook(PC->VTable[SDK::UObject::ProcessEvent_Idx], PEHook, (void**)&o_PEHook);
                Hooks::EnableHook(PC->VTable[SDK::UObject::ProcessEvent_Idx]);
            }

            static SDK::UFunction* FuncA =
                SDK::UObject::GetFunction("FortPlayerController", "ServerCreateBuildingActor");
            static SDK::UClass* Wall = SDK::UObject::FindObjectFast<SDK::UClass>("PBWA_W1_Solid_C");
            static SDK::UClass* Floor = SDK::UObject::FindObjectFast<SDK::UClass>("PBWA_W1_Floor_C");
            static SDK::UClass* Cone = SDK::UObject::FindObjectFast<SDK::UClass>("PBWA_W1_RoofC_C");

            if (Wall && Floor && Cone && FuncA) {
                SDK::FVector2D Poss[] = {
                    {0, 1},
                    {1, 0},
                    {0, -1},
                    {-1, 0},
                };

                constexpr float BuildingSize = 5.12f * 100.f; // wall width (512 UU)
                SDK::FVector    TargetLoc = LocalPawn->RootComponent->RelativeLocation;

                for (int i = 0; i < 4; ++i) {
                    const auto& Pos = Poss[i];

                    FortPlayerController_ServerCreateBuildingActor parms{};
                    parms.BuildingClassData.BuildingClass = Wall;
                    parms.BuildingClassData.PreviousBuildingLevel = -1;
                    parms.BuildingClassData.UpgradeLevel = 0;

                    parms.BuildLoc =
                        SDK::FVector(TargetLoc.X + (Pos.X * (BuildingSize / 2.f)),
                                     TargetLoc.Y + (Pos.Y * (BuildingSize / 2.f)), TargetLoc.Z - (BuildingSize / 2.f));

                    float Yaw = 0.f;
                    if (Pos.X == 1)
                        Yaw = 90.f;
                    else if (Pos.X == -1)
                        Yaw = -90.f;
                    else if (Pos.Y == -1)
                        Yaw = 180.f;

                    parms.BuildRot = SDK::FRotator(0.f, Yaw, 0.f);
                    parms.bMirrored = false;

                    PC->ProcessEvent(FuncA, &parms);
                }

                // Build floor beneath
                {
                    FortPlayerController_ServerCreateBuildingActor parms{};
                    parms.BuildingClassData.BuildingClass = Floor;
                    parms.BuildingClassData.PreviousBuildingLevel = -1;
                    parms.BuildingClassData.UpgradeLevel = 0;
                    parms.BuildLoc = SDK::FVector(TargetLoc.X, TargetLoc.Y - (BuildingSize / 2.f),
                                                  TargetLoc.Z - (BuildingSize / 2.f));
                    parms.BuildRot = SDK::FRotator(0.f, 0.f, 0.f);
                    parms.bMirrored = false;

                    PC->ProcessEvent(FuncA, &parms);
                }

                // Build floor above
                SDK::FVector CeilingLoc =
                    SDK::FVector(TargetLoc.X, TargetLoc.Y - (BuildingSize / 2.f), TargetLoc.Z + (BuildingSize / 4.f));
                {
                    FortPlayerController_ServerCreateBuildingActor parms{};
                    parms.BuildingClassData.BuildingClass = Floor;
                    parms.BuildingClassData.PreviousBuildingLevel = -1;
                    parms.BuildingClassData.UpgradeLevel = 0;
                    parms.BuildLoc = CeilingLoc;
                    parms.BuildRot = SDK::FRotator(0.f, 0.f, 0.f);
                    parms.bMirrored = false;

                    PC->ProcessEvent(FuncA, &parms);
                }

                // Build cone on top of top floor
                {
                    FortPlayerController_ServerCreateBuildingActor parms{};
                    parms.BuildingClassData.BuildingClass = Cone;
                    parms.BuildingClassData.PreviousBuildingLevel = -1;
                    parms.BuildingClassData.UpgradeLevel = 0;
                    parms.BuildLoc = SDK::FVector(CeilingLoc.X, CeilingLoc.Y, CeilingLoc.Z);
                    parms.BuildRot = SDK::FRotator(0.f, 0.f, 0.f);
                    parms.bMirrored = false;

                    PC->ProcessEvent(FuncA, &parms);
                }
            }
        }
    }
#endif
}

// --- Public Tick Functions -----------------------------------------

void TickGameThread() {
    const auto& Config = Config::g_Config.Exploit;
    auto* const LocalPawn = SDK::Cast<SDK::AFortPlayerPawnAthena>(SDK::GetLocalPawn());
    if (!LocalPawn)
        return;

    WeaponExploits(LocalPawn);
    PawnExploits(LocalPawn);
}

} // namespace Exploits
} // namespace Features
